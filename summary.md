#### 实现概述
本次项目的主要难点在锁定座位上，对此我有以下三条较靠谱的思路：
1. 在售票开始前，将所有库存座位打乱放到redis的list中，通过入队和出队原子性操作来分配库存和回收库存。（[即刚开始的思路](https://github.com/pj919715177/ticketSystem/blob/master/README.md)）
2. 锁定座位的时候，先随机座位号seat_id，假设购买n个座位，则选择离seat_id最近的n个座位。假如影响行数小于购买的票数，则说明库存不足，把所有该订单的座位订单id置0。[实现的大概思路点这里>](https://github.com/pj919715177/ticketSystem/blob/master/way2.md)
3. 提交订单时，先检查库存是否足，如果库存足够，先返回给用户，然后支付成功回调后再分配座位，通过触达告知用户座位信息。[实现的大概思路点这里>](https://github.com/pj919715177/ticketSystem/blob/master/way3.md)
### 总结
锁定座位的理想结果是：准确、高并发、高容错、高性能、用户体验好。
- 对第一种方案，准确（联合主键确保永远不会重复分配同一场次的相同座位），高并发（可以并发插入多个座位），高性能（正常的mysql新增删除和redis的lpop、rpush操作，没有太大的性能问题），用户体验好（可以实时、较快的返回购买结果和座位信息）。但是对与容错，在系统异常（服务器挂掉等）情况下，可能造成库存冗余或缺失的情况，需要用定时脚本维护库存准确性，大大增加了系统的复杂度。
- 对第二种方案，准确（与上面类似），高容错（库存只维护一种数据，简单不易出错），但对于高并发、高性能、用户体验方面，因为锁定座位更新订单id的时候，mysql会锁住所有空座位，并发量大的时候，会造成资源等待，严重影响服务器吞吐量，有较大的性能问题，用户侧也会等待比较久。
- 对第三种方案，准确（与上面类似），高容错（与上面类似），高性能，高并发（省略了很多步骤，高并发下反应较快）。但是感觉会有用户体验问题，感觉提交订单一般都会实时返回座位信息吧。而且产品经理一般也不会允许，太影响用户体验了。   

综上所述，如果并发量不高，第二种方法比较好，简单稳定，实时返回座位信息；如果用户体验要求不高，提交订单不需要实时返回座位信息，并发量较高，可以考虑第三种；如果各方面要求较高，可以考虑第一种，但会付出较高的开发和维护成本，redis的list可能会给后续迭代埋坑。
### 其他
因为感觉这个系统会有比较巧妙的实现方法，所以思考了比较久，最后感觉不会有很完美的方案。  
假如在维护一份mysql数据的情况下，可能有一下两种思路:
- 加入不初始化座位，新增座位即锁定座位，实时并发插入数据并避免座位号碰撞（能确保后面随机到的座位号没锁定），这个效果在多线程查询、插入的情况下一定没法实现的，比较有可能的是使用事务先select再insert，或者直接一条sql insert...select,但其实两种情况都会使用mvcc的快照实现读写并发，所以都有可能造成冲突碰撞；
- 假如要对方案二进行优化，实时并发更新（缩小行锁范围），需要有个索引在不同订单的锁定动作有不同的值，并且锁定的时候，是走这个索引的,但是我们没有这个条件。
